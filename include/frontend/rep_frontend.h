#ifndef REP_FRONTEND_H
#define REP_FRONTEND_H

// This is an autogenerated file.
// Do not edit this file, any changes made will be lost the next time it is generated.

#include <QtCore/qobject.h>
#include <QtCore/qdatastream.h>
#include <QtCore/qvariant.h>
#include <QtCore/qmetatype.h>

#include <QtRemoteObjects/qremoteobjectnode.h>
#include <QtRemoteObjects/qremoteobjectpendingcall.h>
#include <QtRemoteObjects/qremoteobjectreplica.h>
#include <QtRemoteObjects/qremoteobjectsource.h>

#include "common/scene.h"

#include "hue/bridge.h"

class FrontendReplica : public QRemoteObjectReplica
{
    Q_OBJECT
    Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_TYPE, "Frontend")
    Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_SIGNATURE, "5be91ff635174601e89707f8da3a83c0b7b2db6d")
    Q_PROPERTY(QList<Scene> scenes READ scenes NOTIFY scenesChanged)
    Q_PROPERTY(QList<Hue::Bridge> bridges READ bridges NOTIFY bridgesChanged)

public:
    FrontendReplica() : QRemoteObjectReplica() { initialize(); }
    static void registerMetatypes()
    {
        static bool initialized = false;
        if (initialized)
            return;
        initialized = true;
        qRegisterMetaType<QList<Hue::Bridge>>();
        qRegisterMetaTypeStreamOperators<QList<Hue::Bridge>>();
        qRegisterMetaType<QList<Scene>>();
        qRegisterMetaTypeStreamOperators<QList<Scene>>();

    }

private:
    FrontendReplica(QRemoteObjectNode *node, const QString &name = QString())
        : QRemoteObjectReplica(ConstructWithNode)
    {
        initializeNode(node, name);
    }

    void initialize() override
    {
        FrontendReplica::registerMetatypes();
        QVariantList properties;
        properties.reserve(2);
        properties << QVariant::fromValue(QList<Scene>());
        properties << QVariant::fromValue(QList<Hue::Bridge>());
        setProperties(properties);
    }

public:
    virtual ~FrontendReplica() {}

    QList<Scene> scenes() const
    {
        const QVariant variant = propAsVariant(0);
        if (!variant.canConvert<QList<Scene>>()) {
            qWarning() << "QtRO cannot convert the property scenes to type QList<Scene>";
        }
        return variant.value<QList<Scene> >();
    }

    QList<Hue::Bridge> bridges() const
    {
        const QVariant variant = propAsVariant(1);
        if (!variant.canConvert<QList<Hue::Bridge>>()) {
            qWarning() << "QtRO cannot convert the property bridges to type QList<Hue::Bridge>";
        }
        return variant.value<QList<Hue::Bridge> >();
    }


Q_SIGNALS:
    void scenesChanged(QList<Scene> scenes);
    void bridgesChanged(QList<Hue::Bridge> bridges);

public Q_SLOTS:
    void pushScenes(QList<Scene> scenes)
    {
        static int __repc_index = FrontendReplica::staticMetaObject.indexOfSlot("pushScenes(QList<Scene>)");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(scenes);
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void pushBridges(QList<Hue::Bridge> bridges)
    {
        static int __repc_index = FrontendReplica::staticMetaObject.indexOfSlot("pushBridges(QList<Hue::Bridge>)");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(bridges);
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }

private:
    friend class QT_PREPEND_NAMESPACE(QRemoteObjectNode);
};

#if (QT_VERSION < QT_VERSION_CHECK(5, 5, 0))
#endif


class FrontendSource : public QObject
{
    Q_OBJECT
    Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_TYPE, "Frontend")
    Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_SIGNATURE, "5be91ff635174601e89707f8da3a83c0b7b2db6d")
    Q_PROPERTY(QList<Scene> scenes READ scenes WRITE setScenes NOTIFY scenesChanged)
    Q_PROPERTY(QList<Hue::Bridge> bridges READ bridges WRITE setBridges NOTIFY bridgesChanged)

public:
    explicit FrontendSource(QObject *parent = nullptr) : QObject(parent)
    {
        qRegisterMetaType<QList<Hue::Bridge>>();
        qRegisterMetaTypeStreamOperators<QList<Hue::Bridge>>();
        qRegisterMetaType<QList<Scene>>();
        qRegisterMetaTypeStreamOperators<QList<Scene>>();

    }

public:
    virtual ~FrontendSource() {}

    virtual QList<Scene> scenes() const = 0;
    virtual QList<Hue::Bridge> bridges() const = 0;
    virtual void setScenes(QList<Scene> scenes) = 0;
    virtual void setBridges(QList<Hue::Bridge> bridges) = 0;

Q_SIGNALS:
    void scenesChanged(QList<Scene> scenes);
    void bridgesChanged(QList<Hue::Bridge> bridges);

public Q_SLOTS:
    virtual void pushScenes(QList<Scene> scenes)
    {
        setScenes(scenes);
    }
    virtual void pushBridges(QList<Hue::Bridge> bridges)
    {
        setBridges(bridges);
    }

private:
    friend class QT_PREPEND_NAMESPACE(QRemoteObjectNode);
};

#if (QT_VERSION < QT_VERSION_CHECK(5, 5, 0))
#endif


class FrontendSimpleSource : public FrontendSource
{
    Q_OBJECT

public:
    explicit FrontendSimpleSource(QObject *parent = nullptr) : FrontendSource(parent)
    , m_scenes()
    , m_bridges()
    {
    }

public:
    virtual ~FrontendSimpleSource() {}

    QList<Scene> scenes() const override { return m_scenes; }
    QList<Hue::Bridge> bridges() const override { return m_bridges; }
    virtual void setScenes(QList<Scene> scenes) override
    {
        if (scenes != m_scenes) {
            m_scenes = scenes;
            Q_EMIT scenesChanged(m_scenes);
        }
    }
    virtual void setBridges(QList<Hue::Bridge> bridges) override
    {
        if (bridges != m_bridges) {
            m_bridges = bridges;
            Q_EMIT bridgesChanged(m_bridges);
        }
    }

private:
    QList<Scene> m_scenes;
    QList<Hue::Bridge> m_bridges;
};


template <class ObjectType>
struct FrontendSourceAPI : public SourceApiMap
{
    FrontendSourceAPI(ObjectType *object, const QString &name = QStringLiteral("Frontend"))
        : SourceApiMap(), m_name(name)
    {
        Q_UNUSED(object);
        m_enums[0] = 0;
        m_properties[0] = 2;
        m_properties[1] = QtPrivate::qtro_property_index<ObjectType>(&ObjectType::scenes, static_cast<QList<Scene> (QObject::*)()>(0),"scenes");
        QtPrivate::qtro_method_test<ObjectType>(&ObjectType::scenesChanged, static_cast<void (QObject::*)()>(0));
        m_properties[2] = QtPrivate::qtro_property_index<ObjectType>(&ObjectType::bridges, static_cast<QList<Hue::Bridge> (QObject::*)()>(0),"bridges");
        QtPrivate::qtro_method_test<ObjectType>(&ObjectType::bridgesChanged, static_cast<void (QObject::*)()>(0));
        m_signals[0] = 2;
        m_signals[1] = QtPrivate::qtro_signal_index<ObjectType>(&ObjectType::scenesChanged, static_cast<void (QObject::*)(QList<Scene>)>(0),m_signalArgCount+0,&m_signalArgTypes[0]);
        m_signals[2] = QtPrivate::qtro_signal_index<ObjectType>(&ObjectType::bridgesChanged, static_cast<void (QObject::*)(QList<Hue::Bridge>)>(0),m_signalArgCount+1,&m_signalArgTypes[1]);
        m_methods[0] = 2;
        m_methods[1] = QtPrivate::qtro_method_index<ObjectType>(&ObjectType::pushScenes, static_cast<void (QObject::*)(QList<Scene>)>(0),"pushScenes(QList<Scene>)",m_methodArgCount+0,&m_methodArgTypes[0]);
        m_methods[2] = QtPrivate::qtro_method_index<ObjectType>(&ObjectType::pushBridges, static_cast<void (QObject::*)(QList<Hue::Bridge>)>(0),"pushBridges(QList<Hue::Bridge>)",m_methodArgCount+1,&m_methodArgTypes[1]);
    }

    QString name() const override { return m_name; }
    QString typeName() const override { return QStringLiteral("Frontend"); }
    int enumCount() const override { return m_enums[0]; }
    int propertyCount() const override { return m_properties[0]; }
    int signalCount() const override { return m_signals[0]; }
    int methodCount() const override { return m_methods[0]; }
    int sourceEnumIndex(int index) const override
    {
        if (index < 0 || index >= m_enums[0])
            return -1;
        return m_enums[index+1];
    }
    int sourcePropertyIndex(int index) const override
    {
        if (index < 0 || index >= m_properties[0])
            return -1;
        return m_properties[index+1];
    }
    int sourceSignalIndex(int index) const override
    {
        if (index < 0 || index >= m_signals[0])
            return -1;
        return m_signals[index+1];
    }
    int sourceMethodIndex(int index) const override
    {
        if (index < 0 || index >= m_methods[0])
            return -1;
        return m_methods[index+1];
    }
    int signalParameterCount(int index) const override
    {
        if (index < 0 || index >= m_signals[0])
            return -1;
        return m_signalArgCount[index];
    }
    int signalParameterType(int sigIndex, int paramIndex) const override
    {
        if (sigIndex < 0 || sigIndex >= m_signals[0] || paramIndex < 0 || paramIndex >= m_signalArgCount[sigIndex])
            return -1;
        return m_signalArgTypes[sigIndex][paramIndex];
    }
    int methodParameterCount(int index) const override
    {
        if (index < 0 || index >= m_methods[0])
            return -1;
        return m_methodArgCount[index];
    }
    int methodParameterType(int methodIndex, int paramIndex) const override
    {
        if (methodIndex < 0 || methodIndex >= m_methods[0] || paramIndex < 0 || paramIndex >= m_methodArgCount[methodIndex])
            return -1;
        return m_methodArgTypes[methodIndex][paramIndex];
    }
    int propertyIndexFromSignal(int index) const override
    {
        switch (index) {
        case 0: return m_properties[1];
        case 1: return m_properties[2];
        }
        return -1;
    }
    int propertyRawIndexFromSignal(int index) const override
    {
        switch (index) {
        case 0: return 0;
        case 1: return 1;
        }
        return -1;
    }
    const QByteArray signalSignature(int index) const override
    {
        switch (index) {
        case 0: return QByteArrayLiteral("scenesChanged(QList<Scene>)");
        case 1: return QByteArrayLiteral("bridgesChanged(QList<Hue::Bridge>)");
        }
        return QByteArrayLiteral("");
    }
    QList<QByteArray> signalParameterNames(int index) const override
    {
        if (index < 0 || index >= m_signals[0])
            return QList<QByteArray>();
        return ObjectType::staticMetaObject.method(m_signals[index + 1]).parameterNames();
    }
    const QByteArray methodSignature(int index) const override
    {
        switch (index) {
        case 0: return QByteArrayLiteral("pushScenes(QList<Scene>)");
        case 1: return QByteArrayLiteral("pushBridges(QList<Hue::Bridge>)");
        }
        return QByteArrayLiteral("");
    }
    QMetaMethod::MethodType methodType(int) const override
    {
        return QMetaMethod::Slot;
    }
    QList<QByteArray> methodParameterNames(int index) const override
    {
        if (index < 0 || index >= m_methods[0])
            return QList<QByteArray>();
        return ObjectType::staticMetaObject.method(m_methods[index + 1]).parameterNames();
    }
    const QByteArray typeName(int index) const override
    {
        switch (index) {
        case 0: return QByteArrayLiteral("void");
        case 1: return QByteArrayLiteral("void");
        }
        return QByteArrayLiteral("");
    }
    QByteArray objectSignature() const override { return QByteArray{"5be91ff635174601e89707f8da3a83c0b7b2db6d"}; }

    int m_enums[1];
    int m_properties[3];
    int m_signals[3];
    int m_methods[3];
    const QString m_name;
    int m_signalArgCount[2];
    const int* m_signalArgTypes[2];
    int m_methodArgCount[2];
    const int* m_methodArgTypes[2];
};

QT_BEGIN_NAMESPACE
QT_END_NAMESPACE


#endif // REP_FRONTEND_H
